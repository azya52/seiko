/**********************************************************************
axasm Copyright 2006, 2007, 2008, 2009 
by Al Williams (alw@al-williams.com).


This file is part of axasm.

axasm is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public Licenses as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

axasm is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY: without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the 
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with axasm (see LICENSE.TXT). 
If not, see http://www.gnu.org/licenses/.

If a non-GPL license is desired, contact the author.

This is the retargetable assembler core file

***********************************************************************/
#include <stdio.h>
#include <unistd.h>
#include <getopt.h>
#define _SOLO_MAIN
#include "soloasm.h"


extern unsigned genasm(unsigned);

static FILE *outfile;

int main(int argc, char *argv[])
{
  unsigned int endmem,i,j;
  unsigned int siz;
  unsigned mask;
  int opt=0;
  int mode=0;
  outfile=stdout;
  while (opt!=-1)
    {
      opt=getopt(argc,argv,"bsvhixo:");
      switch (opt)
	{
	case 's':
	  mode=5;
	  break;
	case 'b':
	  mode=4;
	  break;
	case 'v':
	  mode=3;
	  break;
	case 'i':
	  mode=2;
	  break;
	case 'x':
	  mode=1;
	  break;
	case 'h':
	  mode=0;
	  break;

	case 'o':
	  // note -b must be before -o 
	  outfile=fopen(optarg,"wb");
	  if (!outfile) 
	    {
	      perror(optarg);
	      return 1;
	    }
	  break;
	}
    }
  _solo_info.psize=32;   //default size
  endmem=genasm(1); // let labels get filled in
  if (_solo_info.err==0) endmem=genasm(2); // pass 2 for real
  if (_solo_info.err!=0) 
    {
      fprintf(stderr,"Fatal error. No output generated.\n");
      return 1;
    }
  siz=_solo_info.psize;
  int res = 1;
  switch (mode)
    {
    case 1:
      fprintf(outfile,";Generated by soloasm\n");
      fprintf(outfile,"MEMORY_INITIALIZATION_RADIX=16;\n");
      fprintf(outfile,"MEMORY_INITIALIZATION_VECTOR=\n");
      for (i=_solo_info.begin;i<=_solo_info.end;i++) fprintf(outfile,"%0*X%c\n",siz/4,_solo_info.ary[i],i==_solo_info.end?';':',');
      break;
    case 2:  // basic 64k intel hex file only; psize must be multiple of 8
      mask=0xFF;
      unsigned bytesper=16/(siz/8);
      for (i=_solo_info.begin;i<=_solo_info.end;i+=bytesper)
	{
	  /* need to compute # of output words on this line */
	  unsigned bsize;
	  unsigned lsize=bytesper;  // nominal line size (round up)
	  if (i+lsize>_solo_info.end) 
	      lsize=(_solo_info.end-i)+1;
	  bsize=lsize*bytesper;
	  unsigned csum=lsize+(i>>8)+(i&0xFF);
	  unsigned byt;
	  fprintf(outfile,":");
          fprintf(outfile,"%02x%04x00",bsize,i);
	  for (j=0;j<lsize;j++)
	    {
	      fprintf(outfile,"%02x",_solo_info.ary[i+j]&mask);
	      csum+=_solo_info.ary[i+j]&mask;
	      if (siz>8) 
		{
		  fprintf(outfile,"%02x",byt=(_solo_info.ary[i+j]>>8)&mask);
		  csum+=byt;
		}
	      if (siz>16)
		{
		  fprintf(outfile,"%02x",byt=(_solo_info.ary[i+j]>>16)&mask);
		  csum+=byt;
		}
	      if (siz>24)
		{
		  fprintf(outfile,"%02x",byt=(_solo_info.ary[i+j]>>24)&mask);
		  csum+=byt;
		}
	    }
	  fprintf(outfile,"%02x\n",((~csum)+1)&0xFF);
	}
      fprintf(outfile,":00000001FF\n");
      break;
    case 4:   // binary for 32 bit targets only (arch dependent)
	  fprintf(outfile,"");
      fseek(outfile,_solo_info.begin,SEEK_SET);
      fwrite(_solo_info.ary+_solo_info.begin,1,(_solo_info.end+1-_solo_info.begin)*(siz/8),outfile);
      break;
    case 5: // including mode=0;
		if (mode==3) fprintf(outfile,"@%X ",_solo_info.begin);	    
		for (i=_solo_info.begin;i<=_solo_info.end;i+=16){
		  if (mode!=3 && mode!=0)fprintf(outfile,"%0*X: ",siz==8?4:8,i);
		  for (j=0;j<16;j++) 
			if (i+j<=_solo_info.end) 
			  {
			if (mode==0) fprintf(outfile,"%0*X: ",siz==8?4:8,i+j);
			  fprintf(outfile,"%0*X ",(siz+3)/4,_solo_info.ary[i+j]); 
			  if (mode==0) fprintf(outfile,"\n");
			  }
		  if (mode!=0) fprintf(outfile,"\n");
		}
		break;
      
    default:  // binary for 16 bit targets only (arch dependent)
		fprintf(stdout,"Translate OK!\nResult file size %dB\n",(_solo_info.end+1)*_solo_info.psize/8);
		//fprintf(outfile,"");
		for (int i=_solo_info.begin;i<=_solo_info.end;i++) {
			fputc((_solo_info.ary[i]>>8),outfile);
			fputc(_solo_info.ary[i],outfile);
		}		
		res = 0;
    }
  
  if (outfile!=stdout) fclose(outfile);
  return res;
}

